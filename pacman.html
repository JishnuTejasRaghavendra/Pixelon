<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pac-Man - Pixelon</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: #000;
            font-family: 'Press Start 2P', cursive;
            color: white;
            overflow-x: hidden;
            position: relative;
        }
        #gameContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 5px;
            padding-bottom: 20px;
            width: 100%;
        }
        #gameContainer.with-touch-controls {
            padding-bottom: 160px;
        }
        h1 {
            font-size: clamp(14px, 4vw, 24px);
            margin: 10px 0 5px 0;
            color: #ff0;
        }
        #gameInfo {
            display: flex;
            justify-content: center;
            gap: clamp(15px, 4vw, 30px);
            margin: 10px 0;
            font-size: clamp(10px, 2.5vw, 14px);
        }
        #gameInfo div {
            text-align: center;
        }
        #gameInfo .label {
            font-size: clamp(8px, 2vw, 10px);
            color: #aaa;
            margin-bottom: 5px;
        }
        #canvasWrapper {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
        }
        canvas {
            border: 3px solid #00f;
            background: #000;
            display: block;
            max-width: 100%;
            height: auto;
        }
        #instructions {
            font-size: clamp(8px, 2vw, 12px);
            line-height: 1.8;
            margin: 10px 0;
            padding: 0 10px;
            text-align: center;
        }
        #gameOver {
            display: none;
            font-size: clamp(12px, 3vw, 18px);
            margin: 15px 0;
            padding: 0 10px;
            text-align: center;
            color: #f06;
        }
        .button {
            margin: 10px 5px;
            padding: clamp(10px, 3vw, 15px) clamp(20px, 5vw, 30px);
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(8px, 2vw, 12px);
            border: none;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
        }
        #backButton {
            background: #f06;
            color: white;
        }
        #backButton:hover {
            background: #d04;
        }
        #restartButton {
            display: none;
            background: #ff0;
            color: black;
        }
        #restartButton:hover {
            background: #dd0;
        }
        
        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        #startScreen.hidden {
            display: none;
        }
        #startScreen h2 {
            font-size: clamp(16px, 5vw, 32px);
            margin-bottom: 20px;
            text-align: center;
            padding: 0 20px;
            color: #ff0;
        }
        #startButton {
            padding: clamp(15px, 4vw, 20px) clamp(30px, 8vw, 50px);
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 3vw, 16px);
            background: #ff0;
            color: black;
            border: none;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #dd0;
        }
        
        /* Countdown Overlay */
        #countdown {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            font-size: clamp(60px, 20vw, 120px);
            color: #ff0;
            animation: pulse 0.5s ease-in-out;
        }
        #countdown.show {
            display: flex;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        /* Touch Controls */
        #touchControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            border-top: 3px solid rgba(255, 255, 0, 0.5);
        }
        #touchControls.show {
            display: block;
        }
        .touch-dpad {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 3px;
            padding: 5px;
        }
        .touch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(20px, 6vw, 36px);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            color: white;
            font-weight: bold;
            background: rgba(255, 255, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            transition: background 0.1s;
        }
        .touch-btn:active {
            background: rgba(255, 255, 0, 0.6) !important;
        }
        .touch-btn.up {
            grid-column: 2;
            grid-row: 1;
        }
        .touch-btn.left {
            grid-column: 1;
            grid-row: 2;
        }
        .touch-btn.right {
            grid-column: 3;
            grid-row: 2;
        }
        .touch-btn.down {
            grid-column: 2;
            grid-row: 3;
        }

        /* Responsive Breakpoints */
        @media (max-width: 768px) and (orientation: portrait) {
            #gameContainer.with-touch-controls {
                padding-bottom: 150px;
            }
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            #touchControls.show {
                height: 110px;
            }
            #gameContainer.with-touch-controls {
                padding-bottom: 120px;
                padding-top: 5px;
            }
            h1 {
                font-size: 14px;
                margin: 5px 0;
            }
            #gameInfo {
                font-size: 10px;
            }
            #instructions {
                font-size: 7px;
                line-height: 1.5;
                margin: 5px 0;
            }
        }

        @media (max-width: 480px) {
            #touchControls.show {
                height: 130px;
            }
            #gameContainer.with-touch-controls {
                padding-bottom: 140px;
            }
        }

        @media (max-height: 600px) {
            #touchControls.show {
                height: 100px;
            }
            #gameContainer.with-touch-controls {
                padding-bottom: 110px;
                padding-top: 5px;
            }
            h1 {
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h2>üü° READY TO CHOMP? üü°</h2>
        <p style="font-size: clamp(10px, 2.5vw, 14px); margin: 10px 20px; text-align: center; line-height: 1.8;">
            Eat all the dots!<br>
            Avoid the ghosts!<br>
            Use power pellets to fight back!
        </p>
        <button id="startButton">START GAME</button>
    </div>

    <div id="countdown"></div>

    <div id="gameContainer">
        <h1>üü° PAC-MAN</h1>
        <div id="gameInfo">
            <div>
                <div class="label">SCORE</div>
                <div id="score">0</div>
            </div>
            <div>
                <div class="label">LEVEL</div>
                <div id="level">1</div>
            </div>
            <div>
                <div class="label">LIVES</div>
                <div id="lives">3</div>
            </div>
        </div>
        <div id="canvasWrapper">
            <canvas id="pacmanCanvas"></canvas>
        </div>
        <div id="instructions">
            Desktop: Arrow keys to move<br>
            Mobile: Use D-pad below<br>
            Eat dots and avoid ghosts!
        </div>
        <div id="gameOver"></div>
        <button id="restartButton" class="button">RESTART</button>
        <a href="index.html" id="backButton" class="button">‚Üê BACK</a>
    </div>

    <div id="touchControls">
        <div class="touch-dpad">
            <div class="touch-btn up" id="btnUp">‚ñ≤</div>
            <div class="touch-btn left" id="btnLeft">‚óÑ</div>
            <div class="touch-btn right" id="btnRight">‚ñ∫</div>
            <div class="touch-btn down" id="btnDown">‚ñº</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pacmanCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const livesDisplay = document.getElementById('lives');
        const gameOverDisplay = document.getElementById('gameOver');
        const restartButton = document.getElementById('restartButton');
        const touchControls = document.getElementById('touchControls');
        const gameContainer = document.getElementById('gameContainer');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const countdownDisplay = document.getElementById('countdown');

        let gameStarted = false;
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let lives = 3;

        const TILE_SIZE = 20;
        const COLS = 19;
        const ROWS = 21;
        const SPEED = 1.5 / 60; // 1.5 blocks per second at 60fps = 0.025 blocks per frame
        
        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;

        // Maze layout (0=empty, 1=wall, 2=dot, 3=power pellet, 4=cage)
        let maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,4,1,4,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,1,4,4,4,4,4,4,4,1,2,1,0,0,0],
            [1,1,1,1,2,1,4,1,1,4,1,1,4,1,2,1,1,1,1],
            [0,0,0,0,2,4,4,1,4,4,4,1,4,4,2,0,0,0,0],
            [1,1,1,1,2,1,4,1,1,1,1,1,4,1,2,1,1,1,1],
            [0,0,0,1,2,1,4,4,4,4,4,4,4,1,2,1,0,0,0],
            [1,1,1,1,2,1,4,1,1,1,1,1,4,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,0,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let originalMaze = JSON.parse(JSON.stringify(maze));

        // Grid-based Pac-Man (stays centered on tiles)
        let pacman = {
            x: 9, // Grid position
            y: 15,
            dir: 0, // 0=none, 1=up, 2=right, 3=down, 4=left
            nextDir: 0,
            mouthOpen: 0,
            mouthSpeed: 0.15,
            powered: false,
            powerTimer: 0
        };

        // Ghosts with cage timer
        let ghosts = [
            { x: 9, y: 9, color: '#f00', cageX: 9, cageY: 9, dir: 2, inCage: false, cageTimer: 0 },
            { x: 8, y: 9, color: '#f0f', cageX: 8, cageY: 9, dir: 1, inCage: false, cageTimer: 0 },
            { x: 9, y: 10, color: '#0ff', cageX: 9, cageY: 9, dir: 3, inCage: false, cageTimer: 0 },
            { x: 10, y: 9, color: '#fa0', cageX: 10, cageY: 9, dir: 4, inCage: false, cageTimer: 0 }
        ];

        let totalDots = 0;
        let dotsEaten = 0;

        // Countdown function
        function startCountdown(callback) {
            let count = 3;
            countdownDisplay.textContent = count;
            countdownDisplay.classList.add('show');
            
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownDisplay.textContent = count;
                } else if (count === 0) {
                    countdownDisplay.textContent = 'GO!';
                } else {
                    clearInterval(countInterval);
                    countdownDisplay.classList.remove('show');
                    callback();
                }
            }, 1000);
        }

        // Start button handler
        startButton.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameStarted = true;
            resetGame();
            startCountdown(() => {
                gameRunning = true;
                gameLoop();
            });
        });

        // Detect touch capability
        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                    (navigator.maxTouchPoints > 0) ||
                    (navigator.msMaxTouchPoints > 0));
        }

        // Show touch controls
        function updateTouchControls() {
            if (isTouchDevice() || window.innerWidth <= 768) {
                touchControls.classList.add('show');
                gameContainer.classList.add('with-touch-controls');
            } else {
                touchControls.classList.remove('show');
                gameContainer.classList.remove('with-touch-controls');
            }
        }

        updateTouchControls();

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            switch(e.key) {
                case 'ArrowUp':
                    pacman.nextDir = 1;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    pacman.nextDir = 2;
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    pacman.nextDir = 3;
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    pacman.nextDir = 4;
                    e.preventDefault();
                    break;
            }
        });

        // Touch controls
        const touchButtons = {
            up: document.getElementById('btnUp'),
            down: document.getElementById('btnDown'),
            left: document.getElementById('btnLeft'),
            right: document.getElementById('btnRight')
        };

        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('#touchControls')) {
                e.preventDefault();
            }
        }, { passive: false });

        touchButtons.up.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) pacman.nextDir = 1;
        });

        touchButtons.right.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) pacman.nextDir = 2;
        });

        touchButtons.down.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) pacman.nextDir = 3;
        });

        touchButtons.left.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) pacman.nextDir = 4;
        });

        // Count total dots
        function countDots() {
            totalDots = 0;
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (maze[row][col] === 2 || maze[row][col] === 3) {
                        totalDots++;
                    }
                }
            }
        }

        // Check if can move in direction
        function canMove(x, y, dir) {
            let newX = x;
            let newY = y;
            
            if (dir === 1) newY--;
            if (dir === 2) newX++;
            if (dir === 3) newY++;
            if (dir === 4) newX--;
            
            if (newY < 0 || newY >= ROWS || newX < 0 || newX >= COLS) return false;
            if (maze[newY][newX] === 1) return false;
            
            return true;
        }

        // Update Pac-Man (grid-based movement)
        function updatePacman() {
            // Try to change direction
            if (pacman.nextDir !== 0 && canMove(pacman.x, pacman.y, pacman.nextDir)) {
                pacman.dir = pacman.nextDir;
            }
            
            // Move (grid-based, always centered)
            if (pacman.dir !== 0 && canMove(pacman.x, pacman.y, pacman.dir)) {
                if (pacman.dir === 1) pacman.y--;
                if (pacman.dir === 2) pacman.x++;
                if (pacman.dir === 3) pacman.y++;
                if (pacman.dir === 4) pacman.x--;
            }
            
            // Wrap around
            if (pacman.x < 0) pacman.x = COLS - 1;
            if (pacman.x >= COLS) pacman.x = 0;
            
            // Animate mouth
            pacman.mouthOpen += pacman.mouthSpeed;
            if (pacman.mouthOpen > 0.6 || pacman.mouthOpen < 0) {
                pacman.mouthSpeed *= -1;
            }
            
            // Power pellet timer
            if (pacman.powered) {
                pacman.powerTimer--;
                if (pacman.powerTimer <= 0) {
                    pacman.powered = false;
                }
            }
            
            // Eat dots
            if (maze[pacman.y][pacman.x] === 2) {
                maze[pacman.y][pacman.x] = 0;
                score += 10;
                scoreDisplay.textContent = score;
                dotsEaten++;
                
                if (dotsEaten >= totalDots) {
                    nextLevel();
                }
            } else if (maze[pacman.y][pacman.x] === 3) {
                maze[pacman.y][pacman.x] = 0;
                score += 50;
                scoreDisplay.textContent = score;
                dotsEaten++;
                pacman.powered = true;
                pacman.powerTimer = 300; // 5 seconds
                
                if (dotsEaten >= totalDots) {
                    nextLevel();
                }
            }
        }

        // Update ghosts
        function updateGhosts() {
            ghosts.forEach(ghost => {
                // Handle cage timer
                if (ghost.inCage) {
                    ghost.cageTimer--;
                    if (ghost.cageTimer <= 0) {
                        ghost.inCage = false;
                        ghost.x = ghost.cageX;
                        ghost.y = ghost.cageY - 2; // Exit cage
                    }
                    return; // Skip movement while in cage
                }
                
                // Simple AI - try to move towards/away from Pac-Man
                const targetX = pacman.powered ? 0 : pacman.x;
                const targetY = pacman.powered ? 0 : pacman.y;
                
                const directions = [];
                
                // Prefer direction towards target
                if (targetY < ghost.y && canMove(ghost.x, ghost.y, 1)) directions.push(1);
                if (targetX > ghost.x && canMove(ghost.x, ghost.y, 2)) directions.push(2);
                if (targetY > ghost.y && canMove(ghost.x, ghost.y, 3)) directions.push(3);
                if (targetX < ghost.x && canMove(ghost.x, ghost.y, 4)) directions.push(4);
                
                // Add other valid directions
                if (canMove(ghost.x, ghost.y, 1) && !directions.includes(1)) directions.push(1);
                if (canMove(ghost.x, ghost.y, 2) && !directions.includes(2)) directions.push(2);
                if (canMove(ghost.x, ghost.y, 3) && !directions.includes(3)) directions.push(3);
                if (canMove(ghost.x, ghost.y, 4) && !directions.includes(4)) directions.push(4);
                
                // Don't reverse
                const opposite = { 1: 3, 2: 4, 3: 1, 4: 2 };
                const filtered = directions.filter(d => d !== opposite[ghost.dir]);
                
                if (filtered.length > 0) {
                    ghost.dir = filtered[0];
                }
                
                // Move ghost
                if (ghost.dir === 1) ghost.y--;
                if (ghost.dir === 2) ghost.x++;
                if (ghost.dir === 3) ghost.y++;
                if (ghost.dir === 4) ghost.x--;
                
                // Wrap around
                if (ghost.x < 0) ghost.x = COLS - 1;
                if (ghost.x >= COLS) ghost.x = 0;
                
                // Check collision with Pac-Man
                if (ghost.x === pacman.x && ghost.y === pacman.y) {
                    if (pacman.powered) {
                        // Eat ghost - put in cage for 5 seconds
                        score += 200;
                        scoreDisplay.textContent = score;
                        ghost.x = ghost.cageX;
                        ghost.y = ghost.cageY;
                        ghost.inCage = true;
                        ghost.cageTimer = 300; // 5 seconds at 60fps
                    } else {
                        // Lose life
                        lives--;
                        livesDisplay.textContent = lives;
                        
                        if (lives <= 0) {
                            endGame();
                        } else {
                            // Death - restart countdown
                            gameRunning = false;
                            startCountdown(() => {
                                resetPositions();
                                gameRunning = true;
                            });
                        }
                    }
                }
            });
        }

        // Draw maze with double-line borders
        function drawMaze() {
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const x = col * TILE_SIZE;
                    const y = row * TILE_SIZE;
                    
                    if (maze[row][col] === 1) {
                        // Wall - draw double thin lines
                        ctx.strokeStyle = '#00f';
                        ctx.lineWidth = 2;
                        
                        // Outer border
                        ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                        
                        // Inner border
                        ctx.strokeRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                    } else if (maze[row][col] === 2) {
                        // Dot
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (maze[row][col] === 3) {
                        // Power pellet
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, 5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (maze[row][col] === 4) {
                        // Cage - lighter blue
                        ctx.strokeStyle = '#44f';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    }
                }
            }
        }

        // Draw Pac-Man (centered on tile)
        function drawPacman() {
            const x = pacman.x * TILE_SIZE + TILE_SIZE / 2;
            const y = pacman.y * TILE_SIZE + TILE_SIZE / 2;
            const radius = TILE_SIZE / 2 - 3;
            
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            
            let startAngle = 0;
            if (pacman.dir === 1) startAngle = -Math.PI / 2;
            if (pacman.dir === 2) startAngle = 0;
            if (pacman.dir === 3) startAngle = Math.PI / 2;
            if (pacman.dir === 4) startAngle = Math.PI;
            
            const mouthAngle = pacman.mouthOpen;
            ctx.arc(x, y, radius, startAngle + mouthAngle, startAngle + Math.PI * 2 - mouthAngle);
            ctx.lineTo(x, y);
            ctx.fill();
        }

        // Draw ghosts (centered on tile)
        function drawGhosts() {
            ghosts.forEach(ghost => {
                const x = ghost.x * TILE_SIZE + TILE_SIZE / 2;
                const y = ghost.y * TILE_SIZE + TILE_SIZE / 2;
                const radius = TILE_SIZE / 2 - 3;
                
                // Ghost color or blue when powered
                ctx.fillStyle = pacman.powered && !ghost.inCage ? '#00f' : ghost.color;
                
                // Body
                ctx.beginPath();
                ctx.arc(x, y - radius / 3, radius, Math.PI, 0, false);
                ctx.lineTo(x + radius, y + radius);
                ctx.lineTo(x + radius / 2, y + radius / 2);
                ctx.lineTo(x, y + radius);
                ctx.lineTo(x - radius / 2, y + radius / 2);
                ctx.lineTo(x - radius, y + radius);
                ctx.closePath();
                ctx.fill();
                
                // Eyes (if not powered)
                if (!pacman.powered || ghost.inCage) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(x - 6, y - 4, 5, 7);
                    ctx.fillRect(x + 1, y - 4, 5, 7);
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(x - 4, y - 2, 3, 4);
                    ctx.fillRect(x + 3, y - 2, 3, 4);
                }
            });
        }

        // Reset positions
        function resetPositions() {
            pacman.x = 9;
            pacman.y = 15;
            pacman.dir = 0;
            pacman.nextDir = 0;
            pacman.powered = false;
            
            ghosts[0].x = 9; ghosts[0].y = 9; ghosts[0].inCage = false;
            ghosts[1].x = 8; ghosts[1].y = 9; ghosts[1].inCage = false;
            ghosts[2].x = 9; ghosts[2].y = 10; ghosts[2].inCage = false;
            ghosts[3].x = 10; ghosts[3].y = 9; ghosts[3].inCage = false;
        }

        // Next level
        function nextLevel() {
            level++;
            levelDisplay.textContent = level;
            maze = JSON.parse(JSON.stringify(originalMaze));
            dotsEaten = 0;
            resetPositions();
        }

        // Game loop with SPEED throttle
        let moveCounter = 0;
        const moveInterval = Math.round(1 / SPEED); // Frames between moves

        function gameLoop() {
            if (!gameStarted) return;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameRunning) {
                moveCounter++;
                
                // Only move every moveInterval frames (1.5 blocks per second)
                if (moveCounter >= moveInterval) {
                    moveCounter = 0;
                    updatePacman();
                    updateGhosts();
                }
            }

            drawMaze();
            drawPacman();
            drawGhosts();

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            gameOverDisplay.textContent = `GAME OVER! Score: ${score}`;
            gameOverDisplay.style.display = 'block';
            restartButton.style.display = 'inline-block';
        }

        function resetGame() {
            score = 0;
            level = 1;
            lives = 3;
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            livesDisplay.textContent = lives;
            gameOverDisplay.style.display = 'none';
            restartButton.style.display = 'none';
            
            maze = JSON.parse(JSON.stringify(originalMaze));
            dotsEaten = 0;
            countDots();
            resetPositions();
            moveCounter = 0;
        }

        function restartGame() {
            gameStarted = true;
            startScreen.classList.add('hidden');
            gameOverDisplay.style.display = 'none';
            restartButton.style.display = 'none';
            resetGame();
            startCountdown(() => {
                gameRunning = true;
                gameLoop();
            });
        }

        restartButton.addEventListener('click', restartGame);

        // Handle window resize
        window.addEventListener('resize', updateTouchControls);
        window.addEventListener('orientationchange', () => {
            setTimeout(updateTouchControls, 100);
        });

        // Initialize
        countDots();
    </script>
</body>
</html>
