<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pac-Man - Pixelon</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: #000;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            overflow: hidden;
        }
        #container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            padding-bottom: 20px;
        }
        #container.withpad {
            padding-bottom: 170px;
        }
        h1 {
            font-size: clamp(18px, 4vw, 28px);
            color: #ff0;
            margin: 10px 0;
        }
        #stats {
            display: flex;
            gap: 25px;
            margin: 10px 0;
            font-size: clamp(11px, 2.5vw, 15px);
        }
        canvas {
            border: 4px solid #00f;
            background: #000;
            margin: 10px 0;
            max-width: 100%;
        }
        #info {
            font-size: clamp(9px, 2vw, 13px);
            text-align: center;
            margin: 10px;
            line-height: 2;
        }
        #over {
            display: none;
            font-size: clamp(14px, 3vw, 20px);
            color: #f06;
            margin: 10px;
        }
        button, a {
            margin: 8px;
            padding: 12px 28px;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(9px, 2vw, 13px);
            border: none;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
        }
        #backbtn { background: #f06; color: #fff; }
        #restartbtn {
            display: none;
            background: #ff0;
            color: #000;
        }
        
        #startscreen {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }
        #startscreen.gone { display: none; }
        #startscreen h2 {
            font-size: clamp(20px, 6vw, 36px);
            color: #ff0;
            margin-bottom: 30px;
        }
        #startscreen p {
            font-size: clamp(11px, 2.5vw, 15px);
            text-align: center;
            line-height: 2;
            margin: 20px;
        }
        #gobtn {
            padding: 18px 45px;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(13px, 3vw, 18px);
            background: #ff0;
            color: #000;
            border: none;
            cursor: pointer;
        }
        
        #counter {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.92);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            font-size: clamp(70px, 22vw, 140px);
            color: #ff0;
        }
        #counter.active { display: flex; }
        
        #dpad {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            background: rgba(0,0,0,0.85);
            border-top: 4px solid #ff0;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            padding: 8px;
            z-index: 1000;
        }
        #dpad.active { display: grid; }
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 38px;
            color: #fff;
            background: rgba(255,255,0,0.25);
            border: 3px solid rgba(255,255,255,0.25);
            border-radius: 10px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        .btn:active { background: rgba(255,255,0,0.75); }
        #upbtn { grid-column: 2; grid-row: 1; }
        #leftbtn { grid-column: 1; grid-row: 2; }
        #rightbtn { grid-column: 3; grid-row: 2; }
        #downbtn { grid-column: 2; grid-row: 3; }
    </style>
</head>
<body>
    <div id="startscreen">
        <h2>üü° PAC-MAN üü°</h2>
        <p>
            Eat all the dots!<br>
            Avoid the ghosts!<br>
            Power pellets turn the tables!
        </p>
        <button id="gobtn">START GAME</button>
    </div>

    <div id="counter"></div>

    <div id="container">
        <h1>PAC-MAN</h1>
        <div id="stats">
            <div>SCORE: <span id="scoreval">0</span></div>
            <div>LEVEL: <span id="levelval">1</span></div>
            <div>LIVES: <span id="livesval">3</span></div>
        </div>
        <canvas id="canvas"></canvas>
        <div id="info">
            Desktop: Arrow Keys<br>
            Mobile: Touch Controls Below
        </div>
        <div id="over"></div>
        <button id="restartbtn">RESTART</button>
        <a href="index.html" id="backbtn">‚Üê BACK</a>
    </div>

    <div id="dpad">
        <div class="btn" id="upbtn">‚ñ≤</div>
        <div class="btn" id="leftbtn">‚óÑ</div>
        <div class="btn" id="rightbtn">‚ñ∫</div>
        <div class="btn" id="downbtn">‚ñº</div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const TILE = 20;
        const W = 19;
        const H = 21;
        
        canvas.width = W * TILE;
        canvas.height = H * TILE;

        // Game state
        let gameActive = false;
        let gameStarted = false;
        let score = 0;
        let level = 1;
        let lives = 3;
        let frameCounter = 0;
        let ghostFrameCounter = 0;
        let ghostMoveInterval = 30; // Ghosts move slower than Pac-Man (30 vs 20)
        let dotsTotal = 0;
        let dotsEaten = 0;

        // Maze template
        const MAZE_TEMPLATE = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0],
            [1,1,1,1,2,1,0,1,1,0,1,1,0,1,2,1,1,1,1],
            [0,0,0,0,2,0,0,1,0,0,0,1,0,0,2,0,0,0,0],
            [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
            [0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0],
            [1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,0,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let grid = [];

        // Pac-Man state
        let pacman = {
            x: 9,
            y: 15,
            direction: 0,
            nextDirection: 0,
            mouthAngle: 0,
            powered: false,
            powerFrames: 0
        };

        // Ghosts state
        let ghosts = [
            { x: 9, y: 9, direction: 2, color: '#ff0000', caged: false, cageFrames: 0, immune: false },
            { x: 8, y: 9, direction: 1, color: '#ff00ff', caged: false, cageFrames: 0, immune: false },
            { x: 10, y: 9, direction: 4, color: '#00ffff', caged: false, cageFrames: 0, immune: false },
            { x: 9, y: 10, direction: 3, color: '#ffaa00', caged: false, cageFrames: 0, immune: false }
        ];

        // Helper: is tile walkable?
        function isWalkable(x, y) {
            if (x < 0 || x >= W || y < 0 || y >= H) return false;
            const tile = grid[y][x];
            return tile !== 1; // Wall = 1, everything else is walkable
        }

        // Helper: count dots in maze
        function countDots() {
            dotsTotal = 0;
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    if (grid[y][x] === 2 || grid[y][x] === 3) dotsTotal++;
                }
            }
        }

        // Countdown animation
        function showCountdown(callback) {
            const el = document.getElementById('counter');
            let count = 3;
            el.textContent = count;
            el.classList.add('active');
            
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    el.textContent = count;
                } else if (count === 0) {
                    el.textContent = 'GO!';
                } else {
                    clearInterval(timer);
                    el.classList.remove('active');
                    callback();
                }
            }, 1000);
        }

        // Setup touch controls
        function setupTouchControls() {
            if (('ontouchstart' in window) || window.innerWidth <= 768) {
                document.getElementById('dpad').classList.add('active');
                document.getElementById('container').classList.add('withpad');
            }
        }

        // Start game
        document.getElementById('gobtn').addEventListener('click', () => {
            document.getElementById('startscreen').classList.add('gone');
            gameStarted = true;
            fullReset();
            showCountdown(() => {
                gameActive = true;
                requestAnimationFrame(gameLoop);
            });
        });

        // Restart game
        document.getElementById('restartbtn').addEventListener('click', () => {
            fullReset();
            showCountdown(() => {
                gameActive = true;
            });
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            const key = e.key;
            if (key === 'ArrowUp') { pacman.nextDirection = 1; e.preventDefault(); }
            else if (key === 'ArrowRight') { pacman.nextDirection = 2; e.preventDefault(); }
            else if (key === 'ArrowDown') { pacman.nextDirection = 3; e.preventDefault(); }
            else if (key === 'ArrowLeft') { pacman.nextDirection = 4; e.preventDefault(); }
        });

        // Touch controls - both touchstart AND click for maximum compatibility
        const upBtn = document.getElementById('upbtn');
        const rightBtn = document.getElementById('rightbtn');
        const downBtn = document.getElementById('downbtn');
        const leftBtn = document.getElementById('leftbtn');

        upBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) pacman.nextDirection = 1; });
        upBtn.addEventListener('click', () => { if (gameActive) pacman.nextDirection = 1; });
        
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) pacman.nextDirection = 2; });
        rightBtn.addEventListener('click', () => { if (gameActive) pacman.nextDirection = 2; });
        
        downBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) pacman.nextDirection = 3; });
        downBtn.addEventListener('click', () => { if (gameActive) pacman.nextDirection = 3; });
        
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) pacman.nextDirection = 4; });
        leftBtn.addEventListener('click', () => { if (gameActive) pacman.nextDirection = 4; });

        // Update Pac-Man position
        function updatePacman() {
            // Try to turn if next direction is requested
            if (pacman.nextDirection !== 0) {
                let newX = pacman.x;
                let newY = pacman.y;
                if (pacman.nextDirection === 1) newY--;
                else if (pacman.nextDirection === 2) newX++;
                else if (pacman.nextDirection === 3) newY++;
                else if (pacman.nextDirection === 4) newX--;
                
                if (isWalkable(newX, newY)) {
                    pacman.direction = pacman.nextDirection;
                }
            }

            // Move in current direction
            if (pacman.direction !== 0) {
                let newX = pacman.x;
                let newY = pacman.y;
                if (pacman.direction === 1) newY--;
                else if (pacman.direction === 2) newX++;
                else if (pacman.direction === 3) newY++;
                else if (pacman.direction === 4) newX--;
                
                // Handle wraparound
                if (newX < 0) newX = W - 1;
                if (newX >= W) newX = 0;
                
                if (isWalkable(newX, newY)) {
                    pacman.x = newX;
                    pacman.y = newY;
                }
            }

            // Check for dots/power pellets
            const tile = grid[pacman.y][pacman.x];
            if (tile === 2) {
                grid[pacman.y][pacman.x] = 0;
                score += 10;
                dotsEaten++;
                document.getElementById('scoreval').textContent = score;
                if (dotsEaten >= dotsTotal) nextLevel();
            } else if (tile === 3) {
                grid[pacman.y][pacman.x] = 0;
                score += 50;
                dotsEaten++;
                pacman.powered = true;
                // Random 5-10 seconds (300-600 frames at 60fps)
                pacman.powerFrames = 300 + Math.floor(Math.random() * 300);
                // Clear all immune flags for new power-up
                for (const ghost of ghosts) {
                    ghost.immune = false;
                }
                document.getElementById('scoreval').textContent = score;
                if (dotsEaten >= dotsTotal) nextLevel();
            }
        }

        // BFS Pathfinding - finds shortest path to target
        function findPath(startX, startY, targetX, targetY) {
            const queue = [[startX, startY, []]];
            const visited = new Set();
            visited.add(`${startX},${startY}`);
            
            while (queue.length > 0) {
                const [x, y, path] = queue.shift();
                
                // Found target
                if (x === targetX && y === targetY) {
                    return path;
                }
                
                // Try all 4 directions
                const directions = [
                    [x, y - 1, 1], // Up
                    [x + 1, y, 2], // Right
                    [x, y + 1, 3], // Down
                    [x - 1, y, 4]  // Left
                ];
                
                for (const [nx, ny, dir] of directions) {
                    // Handle wraparound
                    let checkX = nx;
                    if (checkX < 0) checkX = W - 1;
                    if (checkX >= W) checkX = 0;
                    
                    const key = `${checkX},${ny}`;
                    if (!visited.has(key) && isWalkable(checkX, ny)) {
                        visited.add(key);
                        queue.push([checkX, ny, [...path, dir]]);
                    }
                }
            }
            
            return []; // No path found
        }

        // Check if position is occupied by another ghost
        function isOccupiedByGhost(x, y, currentGhost) {
            for (const ghost of ghosts) {
                if (ghost !== currentGhost && !ghost.caged && ghost.x === x && ghost.y === y) {
                    return true;
                }
            }
            return false;
        }

        // Update ghost position with pathfinding
        function updateGhost(ghost) {
            if (ghost.caged) return; // Don't move if in cage

            if (pacman.powered && !ghost.immune) {
                // DIZZY MODE - Move randomly (only if not immune)
                const validDirs = [];
                if (isWalkable(ghost.x, ghost.y - 1)) validDirs.push(1);
                if (isWalkable(ghost.x + 1, ghost.y)) validDirs.push(2);
                if (isWalkable(ghost.x, ghost.y + 1)) validDirs.push(3);
                if (isWalkable(ghost.x - 1, ghost.y)) validDirs.push(4);
                
                if (validDirs.length > 0) {
                    // Pick random direction
                    ghost.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
                }
            } else {
                // CHASE MODE - Use pathfinding to follow Pac-Man
                const path = findPath(ghost.x, ghost.y, pacman.x, pacman.y);
                
                if (path.length > 0) {
                    ghost.direction = path[0]; // Take first step of shortest path
                }
            }

            // Calculate new position
            let newX = ghost.x;
            let newY = ghost.y;
            if (ghost.direction === 1) newY--;
            else if (ghost.direction === 2) newX++;
            else if (ghost.direction === 3) newY++;
            else if (ghost.direction === 4) newX--;

            // Handle wraparound
            if (newX < 0) newX = W - 1;
            if (newX >= W) newX = 0;

            // Only move if walkable AND not occupied by another ghost
            if (isWalkable(newX, newY) && !isOccupiedByGhost(newX, newY, ghost)) {
                ghost.x = newX;
                ghost.y = newY;
            }
        }

        // Check collisions with ghosts
        function checkCollisions() {
            for (const ghost of ghosts) {
                if (ghost.caged) continue;
                if (ghost.x === pacman.x && ghost.y === pacman.y) {
                    // Can only eat ghost if powered AND ghost is NOT immune
                    if (pacman.powered && !ghost.immune) {
                        // Eat ghost - respawn in cage
                        score += 200;
                        document.getElementById('scoreval').textContent = score;
                        ghost.x = 9;
                        ghost.y = 9;
                        ghost.caged = true;
                        ghost.cageFrames = 300; // 5 seconds at 60fps
                    } else {
                        // Ghost kills Pac-Man (either not powered OR ghost is immune)
                        lives--;
                        document.getElementById('livesval').textContent = lives;
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            // Respawn with countdown
                            gameActive = false;
                            showCountdown(() => {
                                resetPositions();
                                gameActive = true;
                            });
                        }
                    }
                }
            }
        }

        // Update cage timers
        function updateCageTimers() {
            for (const ghost of ghosts) {
                if (ghost.caged) {
                    ghost.cageFrames--;
                    if (ghost.cageFrames <= 0) {
                        ghost.caged = false;
                        ghost.y = 7; // Exit cage area
                        ghost.immune = true; // Immune to current power-up
                    }
                }
            }
        }

        // Draw everything
        function draw() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const px = x * TILE;
                    const py = y * TILE;
                    const tile = grid[y][x];

                    if (tile === 1) {
                        // Wall with double-line border
                        ctx.strokeStyle = '#0000ff';
                        ctx.lineWidth = 2;
                        // Outer line
                        ctx.strokeRect(px + 2, py + 2, TILE - 4, TILE - 4);
                        // Inner line
                        ctx.strokeRect(px + 5, py + 5, TILE - 10, TILE - 10);
                    } else if (tile === 2) {
                        // Dot
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(px + TILE/2, py + TILE/2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === 3) {
                        // Power pellet
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(px + TILE/2, py + TILE/2, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw Pac-Man
            const pacX = pacman.x * TILE + TILE/2;
            const pacY = pacman.y * TILE + TILE/2;
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            
            let angle = 0;
            if (pacman.direction === 1) angle = -Math.PI / 2;
            else if (pacman.direction === 2) angle = 0;
            else if (pacman.direction === 3) angle = Math.PI / 2;
            else if (pacman.direction === 4) angle = Math.PI;
            
            const mouthOpen = Math.abs(Math.sin(pacman.mouthAngle)) * 0.5;
            pacman.mouthAngle += 0.25;
            
            ctx.arc(pacX, pacY, TILE/2 - 2, angle + mouthOpen, angle + Math.PI * 2 - mouthOpen);
            ctx.lineTo(pacX, pacY);
            ctx.fill();

            // Draw ghosts
            for (const ghost of ghosts) {
                const gx = ghost.x * TILE + TILE/2;
                const gy = ghost.y * TILE + TILE/2;
                const r = TILE/2 - 2;
                
                // Blue only if powered AND not immune (dizzy mode)
                const isDizzy = pacman.powered && !ghost.immune && !ghost.caged;
                ctx.fillStyle = isDizzy ? '#0000ff' : ghost.color;
                ctx.beginPath();
                ctx.arc(gx, gy - r/3, r, Math.PI, 0, false);
                ctx.lineTo(gx + r, gy + r);
                ctx.lineTo(gx + r/2, gy + r/2);
                ctx.lineTo(gx, gy + r);
                ctx.lineTo(gx - r/2, gy + r/2);
                ctx.lineTo(gx - r, gy + r);
                ctx.closePath();
                ctx.fill();
                
                // Eyes (not shown when dizzy)
                if (!isDizzy) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(gx - 6, gy - 4, 5, 7);
                    ctx.fillRect(gx + 1, gy - 4, 5, 7);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(gx - 4, gy - 2, 3, 4);
                    ctx.fillRect(gx + 3, gy - 2, 3, 4);
                }
            }
        }

        // Game loop
        function gameLoop() {
            if (!gameStarted) return;

            // Always update cage timers (even during countdown)
            updateCageTimers();

            if (gameActive) {
                frameCounter++;
                ghostFrameCounter++;
                
                // Update power-up timer EVERY FRAME (not just when moving)
                if (pacman.powered) {
                    pacman.powerFrames--;
                    if (pacman.powerFrames <= 0) {
                        pacman.powered = false;
                        // Clear all immune flags when power-up ends
                        for (const ghost of ghosts) {
                            ghost.immune = false;
                        }
                    }
                }
                
                // Move Pac-Man every 20 frames = 3 times per second at 60fps
                if (frameCounter >= 20) {
                    frameCounter = 0;
                    updatePacman();
                    checkCollisions();
                }
                
                // Move ghosts at their own speed (slower, increases with level)
                if (ghostFrameCounter >= ghostMoveInterval) {
                    ghostFrameCounter = 0;
                    for (const ghost of ghosts) {
                        updateGhost(ghost);
                    }
                    checkCollisions();
                }
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        // Reset positions only
        function resetPositions() {
            pacman.x = 9;
            pacman.y = 15;
            pacman.direction = 0;
            pacman.nextDirection = 0;
            pacman.powered = false;
            pacman.powerFrames = 0;
            
            ghosts[0].x = 9; ghosts[0].y = 9; ghosts[0].caged = false; ghosts[0].immune = false;
            ghosts[1].x = 8; ghosts[1].y = 9; ghosts[1].caged = false; ghosts[1].immune = false;
            ghosts[2].x = 10; ghosts[2].y = 9; ghosts[2].caged = false; ghosts[2].immune = false;
            ghosts[3].x = 9; ghosts[3].y = 10; ghosts[3].caged = false; ghosts[3].immune = false;
        }

        // Next level
        function nextLevel() {
            level++;
            document.getElementById('levelval').textContent = level;
            grid = JSON.parse(JSON.stringify(MAZE_TEMPLATE));
            dotsEaten = 0;
            countDots();
            resetPositions();
            
            // Make ghosts faster each level (decrease interval by 2, minimum 18)
            ghostMoveInterval = Math.max(18, ghostMoveInterval - 2);
        }

        // Full reset
        function fullReset() {
            score = 0;
            level = 1;
            lives = 3;
            frameCounter = 0;
            ghostFrameCounter = 0;
            ghostMoveInterval = 30; // Reset to initial slow speed
            dotsEaten = 0;
            
            document.getElementById('scoreval').textContent = score;
            document.getElementById('levelval').textContent = level;
            document.getElementById('livesval').textContent = lives;
            document.getElementById('over').style.display = 'none';
            document.getElementById('restartbtn').style.display = 'none';
            
            grid = JSON.parse(JSON.stringify(MAZE_TEMPLATE));
            countDots();
            resetPositions();
        }

        // Game over
        function gameOver() {
            gameActive = false;
            document.getElementById('over').textContent = `GAME OVER! Final Score: ${score}`;
            document.getElementById('over').style.display = 'block';
            document.getElementById('restartbtn').style.display = 'inline-block';
        }

        // Initialize
        setupTouchControls();
        grid = JSON.parse(JSON.stringify(MAZE_TEMPLATE));
        countDots();
    </script>
</body>
</html>
